<head>
</head>
<body>
<h2 align=center>KirbyBase Manual</h2>
<br>
<h3>
1). Connecting to a database.
</h3>

To use Kirbybase, you first need to import the module:

<dl>
<dd><b>from kirbybase import KirbyBase, KBError</b>
</dl>
Then create an instance:
<dl>
<dd><b>db = KirbyBase()</b>
</dl>

By default, the instance is a
local connection using the same memory space as your application.  To
specify a client/server connection, it would look like this:

<dl>
<dd><b>db = KirbyBase('client', '192.168.0.10', '44444')</b>
</dl>

Of course, you would substitute the ip address and port number of your
server and the port you are running the dbserver script on.

<h3>
2). Creating a new table.
</h3>

To create a new table, you specify the physical file name, including
path, that will hold the table, and a list containing the field names
and field types.  For example, to create a table containing information
on World War II planes:

<dl>
<dd><b>result = db.create('./db/plane.tbl', ['name:str', 'country:str', 'speed:int', 'range:int',
 'began_service:datetime.date'])</b>
</dl>

Notice that in the fields list, you separate the field name from the field
type with a colon.  KirbyBase will automatically create a primary key field
for each table called 'recno'.  This field will be auto-incremented each time
a record is inserted.  You can use this field in select, update, and delete
queries, but you can't modify this field.

Field types currently allowed in KirbyBase are 'str', 'int', 'float', bool, datetime.date 
and datetime.datetime.
<b>***New in 1.6***</b>
To achieve compatibility between the Python and Ruby versions of KirbyBase, you can now
use the following field types:  String, Integer, Float, Boolean, Date, and DateTime.  Use these
instead of the above mentioned types if you plan on using your table from both Python and Ruby.
<br><br>
This method call will return True if the table was successfully created.

<h3>
3).  Inserting records.
</h3>

To insert records into a table, you use the insert method:

<dl>
<dd><b>recno = db.insert('./db/plane.tbl', ['P-51', 'USA', 403, 1201])</b>
</dl>

The length of the data list must equal the length of the field list.  Also,
the data types must match.  In the above example, specifying '403', instead
of 403, would have resulted in an error.

<br><br><b>***New in 1.3***</b>
You can now also use a dictionary to specify field values.  Rewriting the above
example to use a dictionary instead of list would look like this:

<dl>
<dd><b>recno = db.insert('./db/plane.tbl', {'name': 'P-51', 'country': 'USA',
'speed': 403, 'range': 1201})</b>
</dl>

<br><br><b>***New in 1.4***</b>
To insert a record with a datetime.date or datetime.datetime field, make sure you
import the datetime module, then create a date or datetime instance, and include
it as one of the items data list.  For example,:

<dl>
<dd><b>recno = db.insert('./db/plane.tbl', ['P-51', 'USA', 403, 1201, datetime.date(1943,11,5)])</b>
</dl>


This method call will return the record number of the newly created record.  This
is an auto-incremented integer generated by KirbyBase.  This number will never
change for the record and can be used as a unique identifier for the record.

<h3>
4.)  Updating records.
</h3>

To update a table, you must specify the criteria for determining which records will
be updated.  To update a single record, you can specify it's recno.  This will
search the table ONLY by this field and will update, at most, one record.  An
example of this would be:

<dl>
<dd><b>result = db.update('./db/plane.tbl', ['recno'], [54], [405], ['speed'])</b>
</dl>

Here we are updating the record with recno equal to 54.  We are changing it's speed to 405 mph.
Specifying an exact recno to match is generally a much faster transaction, because KirbyBase
will match only on that field and it will return as soon as that record has been found, instead
of searching through the entire table.
<br><br>
You can also specify match criteria for one or more fields using either regular
expressions (for str field types) or comparison expressions (for int,float field
types).  You can mix and match.  For example, to update all US planes with a
speed greater than 400 mph:

<dl>
<dd><b>result = db.update('./db/plane.tbl', ['country', 'speed'], ['USA', '>400'], [1500], ['range'])</b>
</dl>

This example will compile 'USA' into a regular expression object and match it against
each record's 'country' value.  It will also do an eval on the value of the 'speed' field
with '>400' concatenated to it (i.e. '403>400').  For each record, if all regular
expression matches return objects(i.e. success) and all comparison expressions return True,
then the record is included in the set of records to be updated with the update criteria.
<br><br>
The update criteria is specified as a list of data values to set the fields to, called updates, and a list
of which fields to update, called a filter.  In the above example, every record that matches the match
criteria will have it's 'range' field set to 1500.  You can, of course, update multiple
fields at one time.  If the filter list is equal to None, then the updates list MUST have a
value for each field in the record, excepting the 'recno' field (which can never be updated).  An example
of this would be:

<dl>
<dd><b> result = db.update('./db/plane.tbl', ['recno'], [106], ['P-47', 'USA', 347, 789, 
datetime.date(1942,12,22)])</b>
</dl>

By specifying an update list that is equal in length and in the same order as the record's fields, you then
do not have to specify which fields you are going to update.  KirbyBase will simply appy each item in the
update list to it's corresponding field in the record.

<br><br><b>***New in 1.3***</b>
You can now also use a dictionary to specify the updates to field values.  Rewriting the above
example to use a dictionary instead of list would look like this:

<dl>
<dd><b> result = db.update('./db/plane.tbl', ['recno'], [106], {'name': 'P-47', 'country': 'USA', 
'speed': 347, 'range': 789})</b>
</dl>
The update method call will return an integer specifying the total number of records that were
updated.

<h3>
5.) Deleting records.
</h3>

Deleting records from a table is similar to updating, except that you don't specify a
update list or a filter list.

As mentioned above, to delete a specific record, just specify 'recno' as the field to
search on and put the exact record number in the patterns list.  So, to delete the
record with recno 456:

<dl>
<dd><b>result = db.delete('./db/plane.tbl', ['recno'], [456])</b>
</dl>

To delete multiple records, you would specify match criteria.  This works exactly the same
as it does for updates.  Therefore, to delete all planes from Germany that have a range
less than 800 miles:

<dl>
<dd><b>result = db.delete('./db/plane.tbl', ['country', 'range'], ['Germany', '<800'])</b>
</dl>

This method call will return an integer specifying the total number of records that were
deleted.

<h3>
6.)  Selecting records.
</h3>

Selecting records from a table is similar to updating and deleting records.  You can either
select a particular record by specifying 'recno' as the search field, or you can use
regular expressions and comparison expressions to select all matching records.  See the
sections on updating and deleting for details on how this works.  
<br><br>
Selecting records by string fields allows you to use the complete power and flexibility of
Python's regular expression engine. For example, if you had a field called plane_type that
held values such as "Bomber", "Fighter", "Fighter-Bomber", and "Recon", and you wanted to
find ONLY the bombers, your select query would be:

<dl>
<dd><b>result = db.select('plane.tbl', ['plane_type'], ['^Bomber'])</b>
</dl>

The ^ at the beginning of '^Bomber' tells Python's regular expression engine to only select records
where the value of plane_type <b>begins</b> with 'Bomber', instead of all records that just contain 
the word bomber, like 'Fighter-Bomber' does.
<br><br>
Selecting records by numeric fields allows you to use standard comparison expressions. For example,
to select all planes that have a speed greater than 300 mph and a range less than 900 miles:

<dl>
<dd><b>result = db.select('./db/plane.tbl', ['speed', 'range'], ['>300', '<900'])</b>
</dl>

You can, of course, combine the two selection methods if you need to select records by both string and
numeric fields.  This would allow you to select, for example, all bombers with a speed greater than
300mph and a range less than 900 miles:

<dl>
<dd><b>result = db.select('plane.tbl', ['plane_type', 'speed', 'range'], ['^Bomber', '>300', '<900'])</b>
</dl>

<b>***New in 1.4***</b>

You can now select records using the new datetime.date and datetime.datetime field types.  This works
similarly to selecting integer or floating type fields.  For example, to select all planes that
entered service before 1940:

<dl>
<dd><b>result = db.select('./db/plane.tbl', ['began_service'], ['<%s' % datetime.date(1940, 1, 1)])</b>
</dl>
<b>***New in 1.6***</b>

Finally, you can select all records easily by doing the following:

<dl>
<dd><b>result = db.select('./db/plane.tbl', ['recno'], ['*'])</b>
</dl>

The select method will return a list of lists.  Each internal list is a record that matched the
select criteria.  It will have all of the fields of the record.  If you only want certain fields
for each record returned, you can specify a filter list.  For example, to select all planes
from the US, but you only want their name and speed:

<dl>
<dd><b>result = db.select('./db/plane.tbl', ['country'], ['USA'], ['name', 'speed'])</b>
</dl>

<b>***New in 1.3***</b>
You can now specify that you want the result set to be sorted by a particular field and the sort
direction.  The sort field argument must be a valid field name in the table.  Also, if you pass a
filter list to the select method, the field name specified in the sort field argument must be a
member of the filter list.  In other words, you can't sort on a field that is not included in the
result set.  Rewriting the above example to sort by plane name would look like this:

<dl>
<dd><b>result = db.select('./db/plane.tbl', ['country'], ['USA'], ['name', 'speed'], sortField='name')</b>
</dl>

If a sort field is specified, the sort direction will default to ascending, to sort in a descending
direction you would pass ascending=FALSE as a keyword argument to the select method.

<h3>
7.)  Packing a table.
</h3>

When KirbyBase deletes a record, it really just fills the entire line in the file with spaces.
Deleting the entire line and moving each subsequent line up one would take too much time.
Also, when a record is updated, if the size of the updated record is greater than the size of
the old record, KirbyBase spaces out that entire line in the file, and rewrites the updated
record at the end of the file.  Again, this is done so that the entire file doesn't have to
be re-written just because one record got updated.

However, this means that after a lot of deletes and updates, a table can have lots of blank
lines in it.  This slows down searches and makes the file bigger than it has to be.  You
can use the pack method to remove these blank lines:

<dl>
<dd><b>result = db.pack('./db/plane.tbl')</b>
</dl>

This method call will return an integer specifiying the number of blank lines that were
removed from the table.

<h3>
8.)  Dropping a table.
</h3>

To delete a table, including the physical file that holds it, use the drop method:

<dl>
<dd><b>result = db.drop('./db/plane.tbl')</b>
</dl>

This method call will return True on success.

<h3>
9).  Misc Methods
</h3>

<dl>
<dd><b>result = db.getFieldNames('./db/plane.tbl')</b>
</dl>

Result will be a list of the table's field names.

<dl>
<dd><b>result = db.getFieldTypes('./db/plane.tbl')</b>
</dl>

Result will be a list of the table's field types(i.e. 'str', 'int', 'float')

<br><br><b>***New in 1.3***</b>
<dl>
<dd><b>totalRecords = db.len('./db/plane.tbl')</b>
</dl>

Result will be an integer showing the total number of records in the table.

<h3>
10). Special Characters in Data
</h3>
Since KirbyBase tables are just plain-text, newline-delimited files with each field delimited by a '|',
certain ASCII characters could cause problems when used as input.  For example, entering a newline
character (\n on Unix, \r\n on Windows) as part of a record's data would cause problems later when
KirbyBase attempted to read this record.  Likewise, using the '|' character in your data would also cause
problems as KirbyBase uses this character as a field delimiter.  Finally, it turns out that Python has
problems handling octal code \032 under Windows (possibly because it equates to Ctrl-Z).
<br><br>
To handle the above special characters as data input, KirbyBase checks all string input data and replaces
the special characters with encodings that are safe.  The following table shows how replacements are done:
<br><br>
<table border=1>
<tr><th>Input Character<th>KirbyBase Replacement
<tr align=center><td>\n<td>&linefeed;
<tr align=center><td>\r<td>&carriage_return;
<tr align=center><td>\032<td>&substitute;
<tr align=center><td>|<td>&pipe;
</table>
<br>
KirbyBase will translate to and from the special characters as data is written to and read from a table.
It should all be transparent to the user.  The only time you would encounter the replacement words is if
you were to open up the physical table file in a text editor or read it in as input outside of KirbyBase.
<br><br>
<h3>
11). Table Structure
</h3>
Every table in KirbyBase is represented by a physical, newline-delimited text-file.  Here is an example:
<br><br>
<b>
<pre>
     6|000000|recno:int|name:str|country:str|speed:int|range:int
1|P-51|USA|403|1201
2|P-51|USA|365|888
3|Sptitfire|England|345|540
4|Oscar|Japan|361|777
5|ME-109|Germany|366|514
6|Zero|Japan|377|912
</pre>
</b>
<br>
The first line is the header rec.  Each field is delimited by a '|'.  The first field in the header
is the record counter.  It is incremented by KirbyBase to create new record numbers when records are
inserted.  The second field in the header is the deleted-records counter.  Every time a line in the
file is blanked-out (see Pack), this number is incremented.  You can use this field in a maintenance
script so that the table is packed whenever the deleted-records counter reaches, say, 5,000 records.
The third field in the header is the recno field.  This field is automatically added to the table
when it is created.  The rest of the fields are whatever you specified when you created the table.
<br><br>
Each record after the header record is simply a line of text.  Newline characters delimit records.


<h3>
12). Server notes
</h3>

There are two server scripts included in the distribution:
<br><br>
<b>kbsimpleserver.py</b> - creates a single-threaded, blocking server.  This means that client requests
are serviced in sequential order.  If one client does a 10,000 record select, the client request queued
behind it for updating one record will have to wait, even if it is going against a different table.
This server is good with small tables and clients that do small, simple queries.
<br><br>
<b>kbthreadedserver.py</b> - creates a multi-threaded, non-blocking server.  This means that each client
that connects runs in it's own thread on the server.  The only time one thread will block the
others is if it has to open a table in write mode (i.e. db.delete, db.update, db.insert).  Even in
this case, it will only block other write requests.  Any selects will not be blocked because they
do not need exclusive access to the table.  And, unlike the simple server script, this server only
blocks if two clients are trying to write to the SAME table.  If one client is updating the plane.tbl
and another client is trying to update the tank.tbl, they will not block each other.  The script
does this by maintaining a list of table locks, instead of just one lock for the whole script.
<br><br>
***Notice:  Although I have tested kbthreadedserver.py some, I would still label it experimental.  Try
it out with some test data and see how it works for you before trying it in a production environment.

<h3>
13). License
</h3>
KirbyBase is licensed under the <a href=http://www.opensource.org/licenses/PythonSoftFoundation.html>
Python Software Foundation License.</a>
</body>

